<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Procreate Vibe Sketch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --workspace-bg: #3f3f46; /* Zinc 700 - Middle Grey */
            --canvas-bg: #ffffff;
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--workspace-bg);
            touch-action: none; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        canvas { display: block; touch-action: none; }
        .glass {
            background: rgba(23, 23, 23, 0.75);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .tool-active {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            color: white !important;
        }
        #ui-layer { pointer-events: none; }
        #ui-layer > * { pointer-events: auto; }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <!-- Pro UI Overlay -->
    <div id="ui-layer" class="fixed inset-0 flex flex-col pointer-events-none p-6">
        
        <!-- Header Controls -->
        <div class="flex justify-between items-center w-full">
            <div class="glass px-4 py-2 rounded-full text-white/70 text-xs font-bold tracking-widest uppercase">
                <span id="zoom-text">100</span>% • <span id="rot-text">0</span>°
            </div>
            
            <div class="flex space-x-2">
                <button onclick="resetView()" class="glass p-3 rounded-full text-white hover:bg-white/10 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                </button>
            </div>
        </div>

        <!-- Vertical Sidebar (Procreate Style) -->
        <div class="flex-1 flex items-center">
            <div class="glass p-2 rounded-3xl flex flex-col space-y-4 shadow-2xl">
                <button id="brush-btn" onclick="setTool('brush')" class="p-4 rounded-2xl text-white/50 tool-active">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 19 7-7 3 3-7 7-3-3Z"/><path d="m18 13-1.5-7.5L2 2l3.5 14.5L13 18l5-5Z"/><path d="m2 2 5 5"/></svg>
                </button>
                <button id="eraser-btn" onclick="setTool('eraser')" class="p-4 rounded-2xl text-white/50">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21H7Z"/><path d="m22 21-2-2"/></svg>
                </button>
                <div class="h-px bg-white/10 mx-2"></div>
                <button onclick="clearCanvas()" class="p-4 rounded-2xl text-white/50 hover:text-red-400">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>
                </button>
            </div>
        </div>

        <!-- Bottom Color Bar -->
        <div class="flex justify-center w-full">
            <div class="glass p-3 rounded-3xl flex items-center space-x-4">
                <div class="flex space-x-3 px-2">
                    <button onclick="setColor('#000000')" class="w-8 h-8 rounded-full bg-black border border-white/20"></button>
                    <button onclick="setColor('#ffffff')" class="w-8 h-8 rounded-full bg-white border border-black/10"></button>
                    <button onclick="setColor('#ff3b30')" class="w-8 h-8 rounded-full bg-[#ff3b30]"></button>
                    <button onclick="setColor('#34c759')" class="w-8 h-8 rounded-full bg-[#34c759]"></button>
                    <button onclick="setColor('#007aff')" class="w-8 h-8 rounded-full bg-[#007aff]"></button>
                </div>
                <div class="h-8 w-px bg-white/10"></div>
                <button onclick="downloadImage()" class="bg-white text-black px-6 py-2 rounded-2xl text-sm font-bold uppercase tracking-tight">
                    Export
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const zoomText = document.getElementById('zoom-text');
        const rotText = document.getElementById('rot-text');

        // Drawing Buffer (The "Paper")
        const buffer = document.createElement('canvas');
        const bctx = buffer.getContext('2d');
        buffer.width = 2400; 
        buffer.height = 3200; // iPad-like aspect ratio
        
        bctx.fillStyle = '#ffffff';
        bctx.fillRect(0, 0, buffer.width, buffer.height);
        bctx.lineCap = 'round';
        bctx.lineJoin = 'round';

        // State
        let state = {
            scale: 0.8,
            rotation: 0,
            offsetX: 0,
            offsetY: 0,
            isDrawing: false,
            tool: 'brush',
            color: '#000000',
            brushSize: 5
        };

        // Pointer Tracking
        let pointers = new Map();
        let gesture = {
            initialDist: 0,
            initialScale: 1,
            initialAngle: 0,
            initialRotation: 0,
            midpoint: { x: 0, y: 0 }
        };

        function init() {
            window.addEventListener('resize', resize);
            resize();
            requestAnimationFrame(loop);
        }

        function resize() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
        }

        function resetView() {
            state.scale = 0.8;
            state.rotation = 0;
            state.offsetX = 0;
            state.offsetY = 0;
        }

        // --- Transformation Math ---
        function screenToBuffer(clientX, clientY) {
            const dpr = window.devicePixelRatio;
            let x = (clientX * dpr) - (canvas.width / 2 + state.offsetX * dpr);
            let y = (clientY * dpr) - (canvas.height / 2 + state.offsetY * dpr);

            // Reverse Rotation
            const cos = Math.cos(-state.rotation);
            const sin = Math.sin(-state.rotation);
            const rx = x * cos - y * sin;
            const ry = x * sin + y * cos;

            // Reverse Scale and Center
            return {
                x: (rx / state.scale) + buffer.width / 2,
                y: (ry / state.scale) + buffer.height / 2
            };
        }

        // --- Interaction ---
        window.addEventListener('pointerdown', e => {
            pointers.set(e.pointerId, e);
            
            if (pointers.size === 1 && e.pointerType === 'pen') {
                state.isDrawing = true;
                const pos = screenToBuffer(e.clientX, e.clientY);
                state.lastX = pos.x;
                state.lastY = pos.y;
            } else if (pointers.size === 2) {
                state.isDrawing = false;
                const p = Array.from(pointers.values());
                gesture.initialDist = Math.hypot(p[1].clientX - p[0].clientX, p[1].clientY - p[0].clientY);
                gesture.initialScale = state.scale;
                gesture.initialAngle = Math.atan2(p[1].clientY - p[0].clientY, p[1].clientX - p[0].clientX);
                gesture.initialRotation = state.rotation;
                gesture.midpoint = {
                    x: (p[0].clientX + p[1].clientX) / 2,
                    y: (p[0].clientY + p[1].clientY) / 2
                };
            }
        });

        window.addEventListener('pointermove', e => {
            if (!pointers.has(e.pointerId)) return;
            pointers.set(e.pointerId, e);

            if (state.isDrawing && e.pointerType === 'pen') {
                const pos = screenToBuffer(e.clientX, e.clientY);
                const pressure = e.pressure || 0.5;
                
                bctx.beginPath();
                bctx.moveTo(state.lastX, state.lastY);
                bctx.lineTo(pos.x, pos.y);
                bctx.strokeStyle = state.tool === 'eraser' ? '#ffffff' : state.color;
                bctx.lineWidth = (state.tool === 'eraser' ? 50 : state.brushSize + (pressure * 15)) / state.scale;
                bctx.stroke();
                
                state.lastX = pos.x;
                state.lastY = pos.y;
            } else if (pointers.size === 2) {
                const p = Array.from(pointers.values());
                
                // Panning
                const currentMidX = (p[0].clientX + p[1].clientX) / 2;
                const currentMidY = (p[0].clientY + p[1].clientY) / 2;
                state.offsetX += (currentMidX - gesture.midpoint.x);
                state.offsetY += (currentMidY - gesture.midpoint.y);
                gesture.midpoint = { x: currentMidX, y: currentMidY };

                // Zooming
                const currentDist = Math.hypot(p[1].clientX - p[0].clientX, p[1].clientY - p[0].clientY);
                state.scale = Math.min(Math.max(gesture.initialScale * (currentDist / gesture.initialDist), 0.25), 4.0);

                // Rotating
                const currentAngle = Math.atan2(p[1].clientY - p[0].clientY, p[1].clientX - p[0].clientX);
                state.rotation = gesture.initialRotation + (currentAngle - gesture.initialAngle);
            }
        });

        window.addEventListener('pointerup', e => {
            pointers.delete(e.pointerId);
            if (pointers.size < 2) gesture.initialDist = 0;
            state.isDrawing = false;
        });

        // --- Render Loop ---
        function loop() {
            const dpr = window.devicePixelRatio;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            // Move to center of screen + user pan
            ctx.translate(canvas.width / 2 + state.offsetX * dpr, canvas.height / 2 + state.offsetY * dpr);
            ctx.rotate(state.rotation);
            ctx.scale(state.scale, state.scale);
            
            // Draw the "Paper" Artboard
            ctx.drawImage(buffer, -buffer.width / 2, -buffer.height / 2);
            
            ctx.restore();

            // Update HUD
            zoomText.innerText = Math.round(state.scale * 100);
            rotText.innerText = Math.round((state.rotation * 180 / Math.PI) % 360);

            requestAnimationFrame(loop);
        }

        // --- UI Actions ---
        function setTool(t) {
            state.tool = t;
            document.getElementById('brush-btn').classList.toggle('tool-active', t === 'brush');
            document.getElementById('eraser-btn').classList.toggle('tool-active', t === 'eraser');
        }

        function setColor(c) {
            state.color = c;
            setTool('brush');
        }

        function clearCanvas() {
            if(confirm("Clear current sketch?")) {
                bctx.fillStyle = '#ffffff';
                bctx.fillRect(0, 0, buffer.width, buffer.height);
            }
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = `artwork-${Date.now()}.png`;
            link.href = buffer.toDataURL();
            link.click();
        }

        init();
    </script>
</body>
</html>
